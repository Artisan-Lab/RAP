# Roadmap of RAP
RAP is a general **static analysis platform** designed to integrate multiple Rust static analyzers while linking Rust compiler for static testing. Currently, it supports  `Macos` and `Linux`, including `Apple Sillicon` and `X86_64` architecture. Our roadmap includes the following plans:

**By 2025, our goal is to achieve a more universal, powerful, and user-friendly static analysis framework.**

## Toolchain

**Virtual Space Support**: Although RAP supports single-file compilation by rustc and [**Cargo**](https://doc.rust-lang.org/cargo/index.html) projects, there is a significant number of projects that have **more complex package management**, namely [**Virtual Workspace**](https://doc.rust-lang.org/cargo/reference/workspaces.html#virtual-workspace). In the future, RAP will support virtual workspaces managed by Cargo rather than [**direct termination**](https://github.com/Artisan-Lab/RAP/blob/c99efee436f2dda92157aafa26d8356ea9630c96/rap/src/bin/cargo-rap.rs#L208).

**LLVM Support**: RAP module includes [**LLVM components**](https://github.com/Artisan-Lab/RAP/tree/c99efee436f2dda92157aafa26d8356ea9630c96/rap-llvm) to support  parsing `LLVM IR`. However, _the logic is quite **cumbersome**_, as it heavily relies on rustc to serialize data and communicate through serialized files during `LLVM` parsing, analysis, and updates. This approach is counterintuitive, and the data structure need to be designed by the developers, lacking a mapping from `LLVM IR` to `MIR`.

**Brief Logger Support**: We **rewrote whole logs** for the [**frontend**](https://github.com/Artisan-Lab/RAP/blob/c99efee436f2dda92157aafa26d8356ea9630c96/rap/src/components/log.rs) and [**backend**](https://github.com/Artisan-Lab/rap-rust/blob/585458366f33f2d028cd55441216cd7b1188c95f/compiler/rustc_mir_transform/src/safedrop_check/log.rs) this spring, achieving a consistent style compared to the previous version. **Timestamps are more concise, color support has been added, and analysis errors are highlighted.** _While the current logger seems friendly to developers, it is still too long and difficult to understand for testers who solely use the platformâ€”they are not farmilar with the underlying logic of the platform._ In the future, we will design a logger system that separates users from developers.

**Toolchain Unit Test Support**: Due to many bugs encountered by `SafeDrop`/`RCanary` after **version migration** and the **uncertainty** due to changes in logs, **the situation is improving**. In the future, we will add **unit tests** for the toolchain, targeting not only the **analyzers** but also the **overall architecture**(including starting analyzers, parsing parameters, and internal errors, ...) to establish better CI/CD.

**Release Version Support**: In the early summer of 2024, **we will publish the first release version** on `HomeBrew`. Since our backend heavily relies on custom rustc and cannot be easily registered with Cargo, this release will also include corresponding `Dockfile` and **precompiled** version.

## `SafeDrop`/`RCanary`
**Latest Rustc Metadata Support**: Although we've migrated `SafeDrop` from ancient versions to a **runnable version**, **that's far from enough**! Hardcoded [`rustc_hir::def_id::DefId`](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir/def_id/struct.DefId.html) based on specific version exists within `SafeDrop`. In the future, we'll refine the troubleshooting to **address the underreporting issues** caused by version migration, and we **welcome analysis problem proposals within the issue**.

**Latest Standard Library Support**: Reflecting on `SafeDrop`'s development process, it has actually been quite a long time. With Rust versions changing over the past four years, [`mem::uninitialized()`](https://doc.rust-lang.org/std/mem/fn.uninitialized.html) function for uninitialized functions has been **deprecated**, and for latest [`mem::MaybeUnit`](https://doc.rust-lang.org/std/mem/union.MaybeUninit.html), `SafeDrop` will attempt a better approach. **Of course, this is a breaking change!**

**Deref Support**: Thanks to the collaboration with our lab partners, we've discovered that user implementations of the [`ops::Deref Trait`](https://doc.rust-lang.org/std/ops/trait.Deref.html) in constructed cases **may also constitute UAF/Double Free issues**. This problem is quite challenging, similar to how **non-local `MIR`** in Rustc cannot be **accessed**. **`Deref` is a function, but in MIR, it is only manifested as an operation [rustc_middle::hir::place::ProjectionKind::Deref](https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/hir/place/enum.ProjectionKind.html#variant.Deref).** It needs to be associated with a specific `Defid`, requiring the **function body** in `MIR`. Moreover, the **return type** should be explicit, which may have several nested dereferences like `***r`.